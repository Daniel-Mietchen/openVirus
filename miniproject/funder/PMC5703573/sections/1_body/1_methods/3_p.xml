<?xml version="1.0" encoding="UTF-8"?>
<p>The probability density of the process producing its first arrival at time 
 <italic>y</italic> in state 
 <italic>j</italic>, given that it started in state 
 <italic>i</italic> at time 0, is the 
 <italic>ij</italic>th element of the matrix 
 <italic>f</italic>(
 <italic>y</italic>) = exp((
 <italic>Q</italic> − Λ)
 <italic>y</italic>)Λ where Λ = diag(λ) [
 <xref rid="pcbi.1005868.ref022" ref-type="bibr">22</xref>]. Following [
 <xref rid="pcbi.1005868.ref023" ref-type="bibr">23</xref>] and [
 <xref rid="pcbi.1005868.ref024" ref-type="bibr">24</xref>], it is straightforward to calculate the likelihood of an observed tree under this process. Let 
 <italic>v</italic> be an internal node of the 
 <italic>τ</italic> other than the root, 
 <italic>u</italic> be its parent, 
 <italic>w</italic> and 
 <italic>z</italic> be its children, and 
 <italic>t</italic>
 <sub>
  <italic>v</italic>
 </sub> be the length of the branch joining 
 <italic>v</italic> to its parent 
 <italic>u</italic>. As in [
 <xref rid="pcbi.1005868.ref024" ref-type="bibr">24</xref>], define 
 <italic>L</italic>
 <sub>
  <italic>i</italic>
 </sub>(
 <italic>v</italic>) to be the likelihood of the subtree rooted at 
 <italic>v</italic> conditioned on the parent 
 <italic>u</italic> being in state 
 <italic>i</italic>. 
 <italic>L</italic>
 <sub>
  <italic>i</italic>
 </sub>(
 <italic>v</italic>) is recursively defined by 
 <disp-formula id="pcbi.1005868.e002">
  <alternatives>
   <graphic xlink:href="pcbi.1005868.e002.jpg" id="pcbi.1005868.e002g" mimetype="image" position="anchor" orientation="portrait" xmlns:xlink="http://www.w3.org/1999/xlink"/>
   <math id="M2">
    <mrow>
     <msub>
      <mi>L</mi>
      <mi>i</mi>
     </msub>
     <mrow>
      <mo>(</mo>
      <mi>v</mi>
      <mo>)</mo>
     </mrow>
     <mo>=</mo>
     <munder>
      <mo>∑</mo>
      <mi>j</mi>
     </munder>
     <mspace width="1pt"/>
     <msub>
      <mi>f</mi>
      <mrow>
       <mi>i</mi>
       <mi>j</mi>
      </mrow>
     </msub>
     <mrow>
      <mo>(</mo>
      <msub>
       <mi>t</mi>
       <mi>v</mi>
      </msub>
      <mo>)</mo>
     </mrow>
     <msub>
      <mi>L</mi>
      <mi>j</mi>
     </msub>
     <mrow>
      <mo>(</mo>
      <mi>w</mi>
      <mo>)</mo>
     </mrow>
     <msub>
      <mi>L</mi>
      <mi>j</mi>
     </msub>
     <mrow>
      <mo>(</mo>
      <mi>z</mi>
      <mo>)</mo>
     </mrow>
     <mo>.</mo>
    </mrow>
   </math>
  </alternatives>
 </disp-formula> At the root of the tree, with children 
 <italic>w</italic> and 
 <italic>z</italic>, 
 <disp-formula id="pcbi.1005868.e003">
  <alternatives>
   <graphic xlink:href="pcbi.1005868.e003.jpg" id="pcbi.1005868.e003g" mimetype="image" position="anchor" orientation="portrait" xmlns:xlink="http://www.w3.org/1999/xlink"/>
   <math id="M3">
    <mtable displaystyle="true">
     <mtr>
      <mtd columnalign="right">
       <mrow>
        <msub>
         <mi>L</mi>
         <mi>i</mi>
        </msub>
        <mrow>
         <mo>(</mo>
         <mi>τ</mi>
         <mo>)</mo>
        </mrow>
       </mrow>
      </mtd>
      <mtd columnalign="center">
       <mrow>
        <mo>=</mo>
       </mrow>
      </mtd>
      <mtd columnalign="left">
       <mrow>
        <msub>
         <mi>π</mi>
         <mi>i</mi>
        </msub>
        <msub>
         <mi>L</mi>
         <mi>i</mi>
        </msub>
        <mrow>
         <mo>(</mo>
         <mi>w</mi>
         <mo>)</mo>
        </mrow>
        <msub>
         <mi>L</mi>
         <mi>i</mi>
        </msub>
        <mrow>
         <mo>(</mo>
         <mi>z</mi>
         <mo>)</mo>
        </mrow>
       </mrow>
      </mtd>
     </mtr>
     <mtr>
      <mtd columnalign="right">
       <mrow>
        <mi>L</mi>
        <mo>(</mo>
        <mi>τ</mi>
        <mo>)</mo>
       </mrow>
      </mtd>
      <mtd columnalign="center">
       <mrow>
        <mo>=</mo>
       </mrow>
      </mtd>
      <mtd columnalign="left">
       <mrow>
        <munder>
         <mo>∑</mo>
         <mi>i</mi>
        </munder>
        <mspace width="1pt"/>
        <msub>
         <mi>L</mi>
         <mi>i</mi>
        </msub>
        <mrow>
         <mo>(</mo>
         <mi>τ</mi>
         <mo>)</mo>
        </mrow>
        <mo>.</mo>
       </mrow>
      </mtd>
     </mtr>
    </mtable>
   </math>
  </alternatives>
 </disp-formula> At a tip node 
 <italic>v</italic> with branch length 
 <italic>t</italic>
 <sub>
  <italic>v</italic>
 </sub>, it is intuitive to define the likelihood using the matrix exp((
 <italic>Q</italic> − Λ)
 <italic>t</italic>
 <sub>
  <italic>v</italic>
 </sub>), which gives the probability density of each state transition and no events occurring up to time 
 <italic>t</italic>
 <sub>
  <italic>v</italic>
 </sub>. However, we found that the parameters which optimized the likelihood with this definition nearly always included one arbitrarily small rate assigned to all tips. For this reason, we simply assigned 
 <italic>L</italic>
 <sub>
  <italic>i</italic>
 </sub>(
 <italic>v</italic>) = 1 for all tips 
 <italic>v</italic>. This approach is likely to overestimate cluster sizes due to inclusion of non-cluster individuals sampled following transmission from a cluster member, as well as individuals who are not currently part of a cluster but were in the past. To optimize the likelihood of this model, we used the covariance matrix adaptation evolution strategy [
 <xref rid="pcbi.1005868.ref025" ref-type="bibr">25</xref>], a black-box, derivative-free optimization algorithm.
</p>
