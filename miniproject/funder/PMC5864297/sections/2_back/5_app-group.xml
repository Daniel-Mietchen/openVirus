<?xml version="1.0" encoding="UTF-8"?>
<app-group>
 <app id="appendix-1">
  <title>Appendix 1</title>
  <sec id="s7" sec-type="appendix">
   <title>Non-parametric Granger Causal Inference</title>
   <boxed-text position="float" orientation="portrait">
    <object-id pub-id-type="doi">10.7554/eLife.30756.032</object-id>
    <sec id="s7-1">
     <title>Standard Implementations of Granger Causal Inference</title>
     <p>Suppose that one is interested in the possibility that a vector series 
      <inline-formula>
       <math id="inf241">
        <msub>
         <mi>Y</mi>
         <mi>t</mi>
        </msub>
       </math>
      </inline-formula> causes another vector 
      <inline-formula>
       <math id="inf242">
        <msub>
         <mi>X</mi>
         <mi>t</mi>
        </msub>
       </math>
      </inline-formula>. Let 
      <inline-formula>
       <math id="inf243">
        <msub>
         <mi>J</mi>
         <mi>n</mi>
        </msub>
       </math>
      </inline-formula> be an information set available at time 
      <inline-formula>
       <math id="inf244">
        <mi>n</mi>
       </math>
      </inline-formula>, consisting of terms of the vector series 
      <inline-formula>
       <math id="inf245">
        <msub>
         <mi>Z</mi>
         <mi>t</mi>
        </msub>
       </math>
      </inline-formula>, that is,
      <disp-formula id="equ12">
       <label>(11)</label>
       <math id="m12">
        <mrow>
         <msub>
          <mi>J</mi>
          <mi>n</mi>
         </msub>
         <mo>=</mo>
         <mrow>
          <mo stretchy="false">{</mo>
          <msub>
           <mi>Z</mi>
           <mi>t</mi>
          </msub>
          <mo>:</mo>
          <mrow>
           <mi>t</mi>
           <mo>≦</mo>
           <mi>n</mi>
          </mrow>
          <mo stretchy="false">}</mo>
         </mrow>
        </mrow>
       </math>
      </disp-formula>
     </p>
     <p>
      <inline-formula>
       <math id="inf246">
        <msub>
         <mi>J</mi>
         <mi>n</mi>
        </msub>
       </math>
      </inline-formula> is said to be a proper information set with respect to 
      <inline-formula>
       <math id="inf247">
        <msub>
         <mi>X</mi>
         <mi>t</mi>
        </msub>
       </math>
      </inline-formula>, if 
      <inline-formula>
       <math id="inf248">
        <msub>
         <mi>X</mi>
         <mi>t</mi>
        </msub>
       </math>
      </inline-formula> is included within 
      <inline-formula>
       <math id="inf249">
        <msub>
         <mi>Z</mi>
         <mi>t</mi>
        </msub>
       </math>
      </inline-formula>. Further, suppose that 
      <inline-formula>
       <math id="inf250">
        <msub>
         <mi>Z</mi>
         <mi>t</mi>
        </msub>
       </math>
      </inline-formula> does not include any component of 
      <inline-formula>
       <math id="inf251">
        <msub>
         <mi>Y</mi>
         <mi>t</mi>
        </msub>
       </math>
      </inline-formula>, and define
      <disp-formula id="equ13">
       <label>(12)</label>
       <math id="m13">
        <mrow>
         <msubsup>
          <mi>J</mi>
          <mi>n</mi>
          <mo>′</mo>
         </msubsup>
         <mo>=</mo>
         <mrow>
          <mo stretchy="false">{</mo>
          <mrow>
           <mo stretchy="false">(</mo>
           <msub>
            <mi>Z</mi>
            <mi>t</mi>
           </msub>
           <mo>,</mo>
           <msub>
            <mi>Y</mi>
            <mi>t</mi>
           </msub>
           <mo stretchy="false">)</mo>
          </mrow>
          <mo>:</mo>
          <mrow>
           <mi>t</mi>
           <mo>≦</mo>
           <mi>n</mi>
          </mrow>
          <mo stretchy="false">}</mo>
         </mrow>
        </mrow>
       </math>
      </disp-formula>
     </p>
     <p>Inferring causality in the mean is easier, and if one is satisfied with using minimum mean square prediction error as the criterion to evaluate incremental predictive power, then one may use linear, one-step-ahead least squares predictors to obtain an operational procedure: If 
      <inline-formula>
       <math id="inf252">
        <mrow>
         <mi>V</mi>
         <mi>A</mi>
         <mi>R</mi>
         <mrow>
          <mo stretchy="false">(</mo>
          <mi>X</mi>
          <mo stretchy="false">|</mo>
          <msub>
           <mi>J</mi>
           <mi>n</mi>
          </msub>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
       </math>
      </inline-formula> is the variance of one-step forecast error of 
      <inline-formula>
       <math id="inf253">
        <msub>
         <mi>X</mi>
         <mrow>
          <mi>n</mi>
          <mo>+</mo>
          <mn>1</mn>
         </mrow>
        </msub>
       </math>
      </inline-formula> given 
      <inline-formula>
       <math id="inf254">
        <msub>
         <mi>J</mi>
         <mi>n</mi>
        </msub>
       </math>
      </inline-formula>, then 
      <inline-formula>
       <math id="inf255">
        <mi>Y</mi>
       </math>
      </inline-formula> is a prima facie cause of 
      <inline-formula>
       <math id="inf256">
        <mi>X</mi>
       </math>
      </inline-formula> with respect to 
      <inline-formula>
       <math id="inf257">
        <msubsup>
         <mi>J</mi>
         <mi>n</mi>
         <mo>′</mo>
        </msubsup>
       </math>
      </inline-formula> if:
      <disp-formula id="equ14">
       <label>(13)</label>
       <math id="m14">
        <mrow>
         <mi>V</mi>
         <mi>A</mi>
         <mi>R</mi>
         <mrow>
          <mo stretchy="false">(</mo>
          <mi>X</mi>
          <mo stretchy="false">|</mo>
          <msubsup>
           <mi>J</mi>
           <mi>n</mi>
           <mo>′</mo>
          </msubsup>
          <mo stretchy="false">)</mo>
         </mrow>
         <mo>&lt;</mo>
         <mi>V</mi>
         <mi>A</mi>
         <mi>R</mi>
         <mrow>
          <mo stretchy="false">(</mo>
          <mi>X</mi>
          <mo stretchy="false">|</mo>
          <msub>
           <mi>J</mi>
           <mi>n</mi>
          </msub>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
       </math>
      </disp-formula>
     </p>
     <p>Testing for bivariate Granger causality 
      <italic>in the mean</italic> involves estimating a linear, reduced-form vector autoregression:
      <disp-formula id="equ15">
       <label>(14)</label>
       <math id="m15">
        <mrow>
         <msub>
          <mi>X</mi>
          <mi>t</mi>
         </msub>
         <mo>=</mo>
         <mrow>
          <mrow>
           <mi>A</mi>
           <mo>⁢</mo>
           <mrow>
            <mo stretchy="false">(</mo>
            <mi>L</mi>
            <mo stretchy="false">)</mo>
           </mrow>
           <mo>⁢</mo>
           <msub>
            <mi>X</mi>
            <mi>t</mi>
           </msub>
          </mrow>
          <mo>+</mo>
          <mrow>
           <mi>B</mi>
           <mo>⁢</mo>
           <mrow>
            <mo stretchy="false">(</mo>
            <mi>L</mi>
            <mo stretchy="false">)</mo>
           </mrow>
           <mo>⁢</mo>
           <msub>
            <mi>Y</mi>
            <mi>t</mi>
           </msub>
          </mrow>
          <mo>+</mo>
          <msub>
           <mi>U</mi>
           <mrow>
            <mi>X</mi>
            <mo>,</mo>
            <mi>t</mi>
           </mrow>
          </msub>
         </mrow>
        </mrow>
       </math>
      </disp-formula>
      <disp-formula id="equ16">
       <label>(15)</label>
       <math id="m16">
        <mrow>
         <msub>
          <mi>Y</mi>
          <mi>t</mi>
         </msub>
         <mo>=</mo>
         <mrow>
          <mrow>
           <mi>C</mi>
           <mo>⁢</mo>
           <mrow>
            <mo stretchy="false">(</mo>
            <mi>L</mi>
            <mo stretchy="false">)</mo>
           </mrow>
           <mo>⁢</mo>
           <msub>
            <mi>X</mi>
            <mi>t</mi>
           </msub>
          </mrow>
          <mo>+</mo>
          <mrow>
           <mi>D</mi>
           <mo>⁢</mo>
           <mrow>
            <mo stretchy="false">(</mo>
            <mi>L</mi>
            <mo stretchy="false">)</mo>
           </mrow>
           <mo>⁢</mo>
           <msub>
            <mi>Y</mi>
            <mi>t</mi>
           </msub>
          </mrow>
          <mo>+</mo>
          <msub>
           <mi>V</mi>
           <mrow>
            <mi>Y</mi>
            <mo>,</mo>
            <mi>t</mi>
           </mrow>
          </msub>
         </mrow>
        </mrow>
       </math>
      </disp-formula>where 
      <inline-formula>
       <math id="inf258">
        <mrow>
         <mi>A</mi>
         <mo>⁢</mo>
         <mrow>
          <mo stretchy="false">(</mo>
          <mi>L</mi>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
       </math>
      </inline-formula>, 
      <inline-formula>
       <math id="inf259">
        <mrow>
         <mi>B</mi>
         <mo>⁢</mo>
         <mrow>
          <mo stretchy="false">(</mo>
          <mi>L</mi>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
       </math>
      </inline-formula>, 
      <inline-formula>
       <math id="inf260">
        <mrow>
         <mi>C</mi>
         <mo>⁢</mo>
         <mrow>
          <mo stretchy="false">(</mo>
          <mi>L</mi>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
       </math>
      </inline-formula>, and 
      <inline-formula>
       <math id="inf261">
        <mrow>
         <mi>D</mi>
         <mo>⁢</mo>
         <mrow>
          <mo stretchy="false">(</mo>
          <mi>L</mi>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
       </math>
      </inline-formula> are one-sided lag polynomials in the lag operator 
      <inline-formula>
       <math id="inf262">
        <mi>L</mi>
       </math>
      </inline-formula> with roots all-distinct, and outside the unit circle. The regression errors 
      <inline-formula>
       <math id="inf263">
        <mrow>
         <msub>
          <mi>U</mi>
          <mrow>
           <mi>X</mi>
           <mo>,</mo>
           <mi>t</mi>
          </mrow>
         </msub>
         <mo>,</mo>
         <msub>
          <mi>V</mi>
          <mrow>
           <mi>Y</mi>
           <mo>,</mo>
           <mi>t</mi>
          </mrow>
         </msub>
        </mrow>
       </math>
      </inline-formula> are assumed to be mutually independent and individually i.i.d. with zero mean and constant variance. We used a standard joint test (
      <inline-formula>
       <math id="inf264">
        <mi>F</mi>
       </math>
      </inline-formula> or 
      <inline-formula>
       <math id="inf265">
        <msup>
         <mi>χ</mi>
         <mn>2</mn>
        </msup>
       </math>
      </inline-formula>-test) to determine whether lagged 
      <inline-formula>
       <math id="inf266">
        <mi>Y</mi>
       </math>
      </inline-formula> has significant linear predictive power for current 
      <inline-formula>
       <math id="inf267">
        <mi>X</mi>
       </math>
      </inline-formula>.
     </p>
     <p>The null hypothesis that 
      <inline-formula>
       <math id="inf268">
        <mi>Y</mi>
       </math>
      </inline-formula> does not strictly Granger cause 
      <inline-formula>
       <math id="inf269">
        <mi>X</mi>
       </math>
      </inline-formula> is rejected if the coefficients of the elements in 
      <inline-formula>
       <math id="inf270">
        <mrow>
         <mi>B</mi>
         <mo>⁢</mo>
         <mrow>
          <mo stretchy="false">(</mo>
          <mi>L</mi>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
       </math>
      </inline-formula> are jointly significantly different from zero.
     </p>
     <p>Linear tests presuppose restrictive and often unrealistic (
      <xref rid="bib30" ref-type="bibr">Darnell and Evans, 1990</xref>; 
      <xref rid="bib38" ref-type="bibr">Epstein, 1987</xref>) structure on data. Brock (
      <xref rid="bib15" ref-type="bibr">Brock, 1991</xref>) presents a simple bivariate model to analytically demonstrate the limitations of linear tests in uncovering nonlinear influence. To address this issue, a number of nonlinear tests have been suggested, 
      <inline-formula>
       <math id="inf271">
        <mrow>
         <mrow>
          <mi>e</mi>
          <mo>.</mo>
          <mi>g</mi>
         </mrow>
         <mo>.</mo>
        </mrow>
       </math>
      </inline-formula>, with generalized, autoregressive, conditional heteroskedasticity (GARCH) models (
      <xref rid="bib6" ref-type="bibr">Asimakopoulos et al., 2000</xref>), using wavelet transforms (
      <xref rid="bib68" ref-type="bibr">Papadimitriou et al., 2003</xref>), or heuristic, additive relationships (
      <xref rid="bib25" ref-type="bibr">Chu et al., 2005</xref>). However, these approaches often assume a class of allowable non-linearities; thus not quite alleviating the problem of presupposed structure. This is not just an academic issue; Granger causality has been shown to be significantly sensitive to non-linear transformations (
      <xref rid="bib74" ref-type="bibr">Roberts and Nord, 1985</xref>).
     </p>
     <p>Non-parametric approaches, 
      <inline-formula>
       <math id="inf272">
        <mrow>
         <mrow>
          <mi>e</mi>
          <mo>.</mo>
          <mi>g</mi>
         </mrow>
         <mo>.</mo>
        </mrow>
       </math>
      </inline-formula> the Hiemstra-Jones (HJ) test (
      <xref rid="bib50" ref-type="bibr">Hiemstra and Jones, 1994</xref>) on the other hand, attempt to completely dispense with presuppositions regarding causality structure. Given two series, 
      <inline-formula>
       <math id="inf273">
        <msub>
         <mi>X</mi>
         <mi>t</mi>
        </msub>
       </math>
      </inline-formula> and 
      <inline-formula>
       <math id="inf274">
        <msub>
         <mi>Y</mi>
         <mi>t</mi>
        </msub>
       </math>
      </inline-formula>, the HJ test (which is a modification of the Baek-Brock test [
      <xref rid="bib7" ref-type="bibr">Baek and Brock, 1992</xref>]) uses correlation integrals to test if the probability of similar futures for 
      <inline-formula>
       <math id="inf275">
        <msub>
         <mi>X</mi>
         <mi>t</mi>
        </msub>
       </math>
      </inline-formula> given similar pasts, change significantly if we condition instead on similar pasts for both 
      <inline-formula>
       <math id="inf276">
        <msub>
         <mi>X</mi>
         <mi>t</mi>
        </msub>
       </math>
      </inline-formula> and 
      <inline-formula>
       <math id="inf277">
        <msub>
         <mi>Y</mi>
         <mi>t</mi>
        </msub>
       </math>
      </inline-formula> simultaneously.
     </p>
     <p>Nevertheless, in order to achieve consistent estimation of the correlation integrals, the data series are required to be ergodic, stationary, and absolutely regular 
      <inline-formula>
       <math id="inf278">
        <mrow>
         <mrow>
          <mi>i</mi>
          <mo>.</mo>
          <mi>e</mi>
         </mrow>
         <mo>.</mo>
        </mrow>
        <mi>β</mi>
       </math>
      </inline-formula>-mixing, with an upper bound on the rate at which the 
      <inline-formula>
       <math id="inf279">
        <mi>β</mi>
       </math>
      </inline-formula>-coefficients approach zero (
      <xref rid="bib34" ref-type="bibr">Denker and Keller, 1983</xref>). The additional assumptions beyond ergodicity and stationarity serve to guarantee that sufficiently separated fragments of the data series are nearly independent. The HJ test and its variants (
      <xref rid="bib35" ref-type="bibr">Diks and Panchenko, 2006</xref>; 
      <xref rid="bib75" ref-type="bibr">Seth and Principe, 2010</xref>) have been quite successful in econometrics; uncovering nonlinear causal relations between money and income (
      <xref rid="bib7" ref-type="bibr">Baek and Brock, 1992</xref>), aggregate stock returns and macroeconomic factors (
      <xref rid="bib51" ref-type="bibr">Hiemstra and Kramer, 1995</xref>), currency future returns (
      <xref rid="bib6" ref-type="bibr">Asimakopoulos et al., 2000</xref>) and stock price and trading volume (
      <xref rid="bib50" ref-type="bibr">Hiemstra and Jones, 1994</xref>). Surprisingly, despite clear evidence that linear tests typically have low power in uncovering nonlinear causation (
      <xref rid="bib50" ref-type="bibr">Hiemstra and Jones, 1994</xref>; 
      <xref rid="bib6" ref-type="bibr">Asimakopoulos et al., 2000</xref>), the application of non-parametric tests has been limited in areas beyond financial and macroeconomic interests.
     </p>
     <sec id="s7-1-1">
      <title>1.1 Our Approach: Non-parametric Approach Based on Probabilistic Automata</title>
      <p>We use a new, non-parametric Granger causality-based test for quantized processes (
       <xref rid="bib22" ref-type="bibr">Chattopadhyay, 2014</xref>).
      </p>
      <p>Going beyond binary hypothesis testing, we quantify the notion of the degree of causal influence between observed data streams, without presupposing any particular model structure. Generative models of causal influence are inferred with no a priori, imposed dynamical structure beyond ergodicity, stationarity, and a form of weak dependence. The explicit generative models may be used for prediction. The proposed inference algorithms are PAC-efficient (
       <xref rid="bib22" ref-type="bibr">Chattopadhyay, 2014</xref>), 
       <inline-formula>
        <math id="inf280">
         <mrow>
          <mi>i</mi>
          <mo>.</mo>
          <mi>e</mi>
         </mrow>
        </math>
       </inline-formula>, we are guaranteed to find good models with high probability, and with small sample complexity.
      </p>
     </sec>
    </sec>
    <sec id="s7-2">
     <title>Modeling Framework: Probabilistic Automata and Crossed Probabilistic Automata</title>
     <p>In this section, we briefly describe the notion of probabilistic automata, the inference problem, the notion of causal states, and the decision fusion strategy for multiple models.</p>
     <sec id="s7-2-1">
      <title>Self Models</title>
      <p>The event catalogue’s quantized data streams may be viewed as sample paths from hidden, quantized stochastic processes that drive the observed dynamics. A self-model for such a stream is a generative model that captures statistically significant symbol patterns that causally determine (in a probabilistic sense) future symbols. A good modeling framework for such self-models are probabilistic finite state automata (PFSA) (
       <xref rid="bib20" ref-type="bibr">Chattopadhyay and Lipson, 2013</xref>; 
       <xref rid="bib22" ref-type="bibr">Chattopadhyay, 2014</xref>).
      </p>
      <p>One such self model, shown in 
       <xref ref-type="fig" rid="fig1">Figure 1</xref> (Plate A(i)), is an example of a simple PFSA with two states generated from a binary symbol sequence. Note that, for this particular example, a sequence 
       <inline-formula>
        <math id="inf281">
         <mn>11</mn>
        </math>
       </inline-formula> localizes or synchronizes the machine to state 
       <inline-formula>
        <math id="inf282">
         <msub>
          <mi>q</mi>
          <mn>2</mn>
         </msub>
        </math>
       </inline-formula>, which then implies that the next symbol is a 
       <inline-formula>
        <math id="inf283">
         <mn>0</mn>
        </math>
       </inline-formula> with a probability of 
       <inline-formula>
        <math id="inf284">
         <mn>0.1</mn>
        </math>
       </inline-formula> and a 
       <inline-formula>
        <math id="inf285">
         <mn>1</mn>
        </math>
       </inline-formula> with a probability of 
       <inline-formula>
        <math id="inf286">
         <mn>0.9</mn>
        </math>
       </inline-formula>. Thus, given this stream’s self-model, along with the short history 
       <inline-formula>
        <math id="inf287">
         <mn>11</mn>
        </math>
       </inline-formula>, we can predict the symbol distribution in the next time step. Notably, the states in a PFSA are not the alphabet symbols themselves, but are equivalence classes of symbol sequences (histories) that lead to statistically equivalent futures. This particular example has two states–not because of the fact that the alphabet is binary, but because there are only two distinct distributions that dictate the next symbol from any point in the dynamical evolution. The symbol value is distributed as either 
       <inline-formula>
        <math id="inf288">
         <mrow>
          <mo stretchy="false">[</mo>
          <mn>0.1 0.9</mn>
          <mo stretchy="false">]</mo>
         </mrow>
        </math>
       </inline-formula> or 
       <inline-formula>
        <math id="inf289">
         <mrow>
          <mo stretchy="false">[</mo>
          <mn>0.3 0.7</mn>
          <mo stretchy="false">]</mo>
         </mrow>
        </math>
       </inline-formula> over the binary event alphabet, and the current context or ‘state’ dictates which distribution is in effect chosen. These contexts are simply historical sequence equivalence classes that could have potentially lead to the present state; the specific history belonging to whichever current equivalence class actually transpired makes no difference in the future. Hence, these classes are dynamical states for the discrete stochastic evolution of the system at hand. The transition structure of the PFSA (represented in the graph as the labeled edges with probabilities) specifies how we move between these classes as new symbols are generated, or as new data is acquired.
      </p>
      <p>The inference problem here is to determine both the number of states and the transition structure given a sufficiently long, quantized data stream. In our unsupervised approach, there are no restrictions on admissible graphs for the inferred PFSA, and no a priori constraints on the number of states that may appear (
       <xref rid="bib20" ref-type="bibr">Chattopadhyay and Lipson, 2013</xref>).
      </p>
      <p>Thus, the number of states inferred by our algorithm is a direct measure of the statistical complexity of the underlying process (
       <xref rid="bib29" ref-type="bibr">Crutchfield, 1994</xref>). An inferred single-state, self model implies that the stream is a sequence of independently generated symbols (white noise or a Bernoulli process), and is therefore uninformative.
      </p>
      <p>The inference algorithm identifies the number of causal states by searching for distinct ‘contexts’–sequences which, once transpired, lead to a distinct probability distribution of the next symbol. The computation proceeds as follows (
       <xref rid="bib20" ref-type="bibr">Chattopadhyay and Lipson, 2013</xref>):
      </p>
      <list list-type="order">
       <list-item>
        <p>Let the set of all possible sequences up to a length 
         <inline-formula>
          <math id="inf290">
           <mi>L</mi>
          </math>
         </inline-formula> be denoted as 
         <inline-formula>
          <math id="inf291">
           <msub>
            <mi>S</mi>
            <mi>L</mi>
           </msub>
          </math>
         </inline-formula>.
        </p>
       </list-item>
       <list-item>
        <p>Compute the probability of a future symbol (at a specified time shift) being 
         <inline-formula>
          <math id="inf292">
           <msub>
            <mi>σ</mi>
            <mn>0</mn>
           </msub>
          </math>
         </inline-formula> or 
         <inline-formula>
          <math id="inf293">
           <msub>
            <mi>σ</mi>
            <mn>1</mn>
           </msub>
          </math>
         </inline-formula> after a specific string 
         <inline-formula>
          <math id="inf294">
           <mi>ω</mi>
          </math>
         </inline-formula> from the set 
         <inline-formula>
          <math id="inf295">
           <msub>
            <mi>S</mi>
            <mi>L</mi>
           </msub>
          </math>
         </inline-formula> is encountered; call this distribution 
         <inline-formula>
          <math id="inf296">
           <msub>
            <mi>ϕ</mi>
            <mi>ω</mi>
           </msub>
          </math>
         </inline-formula> for the string 
         <inline-formula>
          <math id="inf297">
           <mi>ω</mi>
          </math>
         </inline-formula>.
        </p>
       </list-item>
       <list-item>
        <p>Call the set of probability distributions obtained by this method as 
         <inline-formula>
          <math id="inf298">
           <mi mathvariant="normal">Φ</mi>
          </math>
         </inline-formula>.
        </p>
       </list-item>
       <list-item>
        <p>Find clusters in the set 
         <inline-formula>
          <math id="inf299">
           <mi mathvariant="normal">Φ</mi>
          </math>
         </inline-formula>, such that individual clusters are separated by some pre-specified distance 
         <inline-formula>
          <math id="inf300">
           <mrow>
            <mi>ϵ</mi>
            <mo>&gt;</mo>
            <mn>0</mn>
           </mrow>
          </math>
         </inline-formula>. These clusters represent the causal states, as they are classes of histories (sequences) that lead to identical, immediate future.
        </p>
       </list-item>
       <list-item>
        <p>Suppose string 
         <inline-formula>
          <math id="inf301">
           <mi>ω</mi>
          </math>
         </inline-formula> is in cluster 
         <inline-formula>
          <math id="inf302">
           <msub>
            <mi>q</mi>
            <mi>i</mi>
           </msub>
          </math>
         </inline-formula>, and sequence 
         <inline-formula>
          <math id="inf303">
           <mrow>
            <mi>ω</mi>
            <mo>⁢</mo>
            <msub>
             <mi>σ</mi>
             <mn>0</mn>
            </msub>
           </mrow>
          </math>
         </inline-formula> is in cluster 
         <inline-formula>
          <math id="inf304">
           <msub>
            <mi>q</mi>
            <mi>j</mi>
           </msub>
          </math>
         </inline-formula>; it then follows that, in the inferred PFSA, there is a transition labeled 
         <inline-formula>
          <math id="inf305">
           <msub>
            <mi>σ</mi>
            <mn>0</mn>
           </msub>
          </math>
         </inline-formula> from the corresponding state 
         <inline-formula>
          <math id="inf306">
           <msub>
            <mi>q</mi>
            <mi>i</mi>
           </msub>
          </math>
         </inline-formula> to state 
         <inline-formula>
          <math id="inf307">
           <msub>
            <mi>q</mi>
            <mi>j</mi>
           </msub>
          </math>
         </inline-formula>. Carrying out this procedure for each symbol of the alphabet for each inferred cluster or state identifies the complete transition structure of the model.
        </p>
       </list-item>
       <list-item>
        <p>Once the transition structure is identified, we choose an arbitrary initial state and step through the model as dictated by the input data stream. We count the number of times each edge or transition is traversed, and, by normalizing the count, we arrive at an estimate of the edge probabilities.</p>
       </list-item>
      </list>
      <p>This completes the PFSA inference.</p>
     </sec>
     <sec id="s7-2-2">
      <title>Formal Definition of PFSAs and Future Prediction</title>
      <p>Mathematically, a PFSA is a 
       <inline-formula>
        <math id="inf308">
         <mn>4</mn>
        </math>
       </inline-formula>-tuple 
       <inline-formula>
        <math id="inf309">
         <mrow>
          <mi>G</mi>
          <mo>=</mo>
          <mrow>
           <mo stretchy="false">(</mo>
           <mi>Q</mi>
           <mo>,</mo>
           <mi mathvariant="normal">Σ</mi>
           <mo>,</mo>
           <mi>δ</mi>
           <mo>,</mo>
           <mover accent="true">
            <mi>π</mi>
            <mo>~</mo>
           </mover>
           <mo stretchy="false">)</mo>
          </mrow>
         </mrow>
        </math>
       </inline-formula>, where 
       <inline-formula>
        <math id="inf310">
         <mi>Q</mi>
        </math>
       </inline-formula> is the set of states, 
       <inline-formula>
        <math id="inf311">
         <mi mathvariant="normal">Σ</mi>
        </math>
       </inline-formula> is the symbol alphabet, 
       <inline-formula>
        <math id="inf312">
         <mrow>
          <mi>δ</mi>
          <mo>:</mo>
          <mrow>
           <mrow>
            <mi>Q</mi>
            <mo>×</mo>
            <mi mathvariant="normal">Σ</mi>
           </mrow>
           <mo>→</mo>
           <mi>Q</mi>
          </mrow>
         </mrow>
        </math>
       </inline-formula> is the transition function specifying the graph structure such that for any state 
       <inline-formula>
        <math id="inf313">
         <mrow>
          <mi>q</mi>
          <mo>∈</mo>
          <mi>Q</mi>
         </mrow>
        </math>
       </inline-formula>, 
       <inline-formula>
        <math id="inf314">
         <mrow>
          <mrow>
           <mi>δ</mi>
           <mo>⁢</mo>
           <mrow>
            <mo stretchy="false">(</mo>
            <mi>q</mi>
            <mo>,</mo>
            <mi>σ</mi>
            <mo stretchy="false">)</mo>
           </mrow>
          </mrow>
          <mo>∈</mo>
          <mi>Q</mi>
         </mrow>
        </math>
       </inline-formula> is the end state of the transition from state 
       <inline-formula>
        <math id="inf315">
         <mi>q</mi>
        </math>
       </inline-formula> via symbol 
       <inline-formula>
        <math id="inf316">
         <mi>σ</mi>
        </math>
       </inline-formula>, and 
       <inline-formula>
        <math id="inf317">
         <mrow>
          <mover accent="true">
           <mi>π</mi>
           <mo>~</mo>
          </mover>
          <mo>:</mo>
          <mrow>
           <mrow>
            <mi mathvariant="normal">Σ</mi>
            <mo>×</mo>
            <mi>Q</mi>
           </mrow>
           <mo>→</mo>
           <mrow>
            <mo stretchy="false">[</mo>
            <mn>0</mn>
            <mo>,</mo>
            <mn>1</mn>
            <mo stretchy="false">]</mo>
           </mrow>
          </mrow>
         </mrow>
        </math>
       </inline-formula> is the symbol probability function such that for any state 
       <inline-formula>
        <math id="inf318">
         <mrow>
          <mi>q</mi>
          <mo>∈</mo>
          <mi>Q</mi>
         </mrow>
        </math>
       </inline-formula>, 
       <inline-formula>
        <math id="inf319">
         <mrow>
          <mrow>
           <mover accent="true">
            <mi>π</mi>
            <mo>~</mo>
           </mover>
           <mo>⁢</mo>
           <mrow>
            <mo stretchy="false">(</mo>
            <mi>q</mi>
            <mo>,</mo>
            <mi>σ</mi>
            <mo stretchy="false">)</mo>
           </mrow>
          </mrow>
          <mo>∈</mo>
          <mrow>
           <mo stretchy="false">[</mo>
           <mn>0</mn>
           <mo>,</mo>
           <mn>1</mn>
           <mo stretchy="false">]</mo>
          </mrow>
         </mrow>
        </math>
       </inline-formula> is the probability of generating the symbol 
       <inline-formula>
        <math id="inf320">
         <mrow>
          <mi>σ</mi>
          <mo>∈</mo>
          <mi mathvariant="normal">Σ</mi>
         </mrow>
        </math>
       </inline-formula> from the state 
       <inline-formula>
        <math id="inf321">
         <mi>q</mi>
        </math>
       </inline-formula>, with the constraint:
       <disp-formula id="equ17">
        <label>(16)</label>
        <math id="m17">
         <mrow>
          <mrow>
           <mrow>
            <mo>∀</mo>
            <mi>q</mi>
           </mrow>
           <mo>∈</mo>
           <mi>Q</mi>
          </mrow>
          <mo>,</mo>
          <mrow>
           <mrow>
            <munder>
             <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
             <mrow>
              <mi>σ</mi>
              <mo>∈</mo>
              <mi mathvariant="normal">Σ</mi>
             </mrow>
            </munder>
            <mrow>
             <mover accent="true">
              <mi>π</mi>
              <mo>~</mo>
             </mover>
             <mo>⁢</mo>
             <mrow>
              <mo stretchy="false">(</mo>
              <mi>q</mi>
              <mo>,</mo>
              <mi>σ</mi>
              <mo stretchy="false">)</mo>
             </mrow>
            </mrow>
           </mrow>
           <mo>=</mo>
           <mn>1</mn>
          </mrow>
         </mrow>
        </math>
       </disp-formula>
      </p>
      <p>We specify a time shift 
       <inline-formula>
        <math id="inf322">
         <mi mathvariant="normal">Δ</mi>
        </math>
       </inline-formula> when we infer a PFSA 
       <inline-formula>
        <math id="inf323">
         <mi>G</mi>
        </math>
       </inline-formula> from a given input stream; this time shift is the delay with which the inferred model makes predictions. Specifically, each transition step in 
       <inline-formula>
        <math id="inf324">
         <mi>G</mi>
        </math>
       </inline-formula> is translated to 
       <inline-formula>
        <math id="inf325">
         <mi mathvariant="normal">Δ</mi>
        </math>
       </inline-formula> steps in the quantized stream. Thus, if we know that the current state in the model is 
       <inline-formula>
        <math id="inf326">
         <msub>
          <mi>q</mi>
          <mn>0</mn>
         </msub>
        </math>
       </inline-formula>, then the predicted symbol 
       <inline-formula>
        <math id="inf327">
         <mi mathvariant="normal">Δ</mi>
        </math>
       </inline-formula> steps for the future are 
       <inline-formula>
        <math id="inf328">
         <mi>σ</mi>
        </math>
       </inline-formula> with probability 
       <inline-formula>
        <math id="inf329">
         <mrow>
          <mover accent="true">
           <mi>π</mi>
           <mo>~</mo>
          </mover>
          <mo>⁢</mo>
          <mrow>
           <mo stretchy="false">(</mo>
           <msub>
            <mi>q</mi>
            <mn>0</mn>
           </msub>
           <mo>,</mo>
           <mi>σ</mi>
           <mo stretchy="false">)</mo>
          </mrow>
         </mrow>
        </math>
       </inline-formula>.
      </p>
      <p>Note that, if we have two models 
       <inline-formula>
        <math id="inf336">
         <mrow>
          <msub>
           <mi>G</mi>
           <mn>1</mn>
          </msub>
          <mo>=</mo>
          <mrow>
           <mo stretchy="false">(</mo>
           <msub>
            <mi>Q</mi>
            <mn>1</mn>
           </msub>
           <mo>,</mo>
           <mi mathvariant="normal">Σ</mi>
           <mo>,</mo>
           <msub>
            <mi>δ</mi>
            <mn>1</mn>
           </msub>
           <mo>,</mo>
           <msub>
            <mover accent="true">
             <mi>π</mi>
             <mo>~</mo>
            </mover>
            <mn>1</mn>
           </msub>
           <mo stretchy="false">)</mo>
          </mrow>
         </mrow>
        </math>
       </inline-formula> and 
       <inline-formula>
        <math id="inf337">
         <mrow>
          <msub>
           <mi>G</mi>
           <mn>2</mn>
          </msub>
          <mo>=</mo>
          <mrow>
           <mo stretchy="false">(</mo>
           <msub>
            <mi>Q</mi>
            <mn>2</mn>
           </msub>
           <mo>,</mo>
           <mi mathvariant="normal">Σ</mi>
           <mo>,</mo>
           <msub>
            <mi>δ</mi>
            <mn>2</mn>
           </msub>
           <mo>,</mo>
           <msub>
            <mover accent="true">
             <mi>π</mi>
             <mo>~</mo>
            </mover>
            <mn>2</mn>
           </msub>
           <mo stretchy="false">)</mo>
          </mrow>
         </mrow>
        </math>
       </inline-formula> with time shifts 
       <inline-formula>
        <math id="inf338">
         <msub>
          <mi mathvariant="normal">Δ</mi>
          <mn>1</mn>
         </msub>
        </math>
       </inline-formula> and 
       <inline-formula>
        <math id="inf339">
         <msub>
          <mi mathvariant="normal">Δ</mi>
          <mn>2</mn>
         </msub>
        </math>
       </inline-formula> respectively, it follows that with each step the models make predictions at different points in time in the future.
      </p>
      <p>Note that to make a prediction using a PFSA, we must know its current state. This is non-trivial in general due to the synchronization problem (
       <xref rid="bib20" ref-type="bibr">Chattopadhyay and Lipson, 2013</xref>; 
       <xref rid="bib22" ref-type="bibr">Chattopadhyay, 2014</xref>). We find an approximation of the current state as follows:
      </p>
      <list list-type="order">
       <list-item>
        <p>Compute the he PFSA states’ stationary distribution using standard Markov chain tools.</p>
       </list-item>
       <list-item>
        <p>Treat the stationary distribution row vector 
         <inline-formula>
          <math id="inf340">
           <mi mathvariant="normal">℘</mi>
          </math>
         </inline-formula> as the initial state distribution. The rationale here is that if we assume that the model has been operating for a sufficient length of time, the current distribution must be very close to the stationary distribution in the expected sense.
        </p>
       </list-item>
       <list-item>
        <p>Compute the square matrices, 
         <inline-formula>
          <math id="inf341">
           <mrow>
            <msub>
             <mi mathvariant="normal">Γ</mi>
             <mi>σ</mi>
            </msub>
            <mo>∈</mo>
            <msup>
             <mi>ℝ</mi>
             <mrow>
              <mrow>
               <mo stretchy="false">|</mo>
               <mi>Q</mi>
               <mo stretchy="false">|</mo>
              </mrow>
              <mo>×</mo>
              <mrow>
               <mo stretchy="false">|</mo>
               <mi>Q</mi>
               <mo stretchy="false">|</mo>
              </mrow>
             </mrow>
            </msup>
           </mrow>
          </math>
         </inline-formula>, for each symbol 
         <inline-formula>
          <math id="inf342">
           <mrow>
            <mi>σ</mi>
            <mo>∈</mo>
            <mi mathvariant="normal">Σ</mi>
           </mrow>
          </math>
         </inline-formula>, such that the 
         <inline-formula>
          <math id="inf343">
           <mrow>
            <mi>i</mi>
            <mo>⁢</mo>
            <msup>
             <mi>j</mi>
             <mrow>
              <mi>t</mi>
              <mo>⁢</mo>
              <mi>h</mi>
             </mrow>
            </msup>
           </mrow>
          </math>
         </inline-formula> element of 
         <inline-formula>
          <math id="inf344">
           <msub>
            <mi mathvariant="normal">Γ</mi>
            <mi>σ</mi>
           </msub>
          </math>
         </inline-formula>, denoted as 
         <inline-formula>
          <math id="inf345">
           <msub>
            <mrow>
             <msub>
              <mi mathvariant="normal">Γ</mi>
              <mi>σ</mi>
             </msub>
             <mo fence="true">|</mo>
            </mrow>
            <mrow>
             <mi>i</mi>
             <mo>⁢</mo>
             <mi>j</mi>
            </mrow>
           </msub>
          </math>
         </inline-formula>, which signifies the probability of going from state 
         <inline-formula>
          <math id="inf346">
           <msub>
            <mi>q</mi>
            <mi>i</mi>
           </msub>
          </math>
         </inline-formula> to state 
         <inline-formula>
          <math id="inf347">
           <msub>
            <mi>q</mi>
            <mi>j</mi>
           </msub>
          </math>
         </inline-formula> via the symbol 
         <inline-formula>
          <math id="inf348">
           <mi>σ</mi>
          </math>
         </inline-formula>.
        </p>
       </list-item>
       <list-item>
        <p>Use a relatively short history 
         <inline-formula>
          <math id="inf349">
           <mrow>
            <mi>h</mi>
            <mo>=</mo>
            <mrow>
             <msub>
              <mi>σ</mi>
              <mn>1</mn>
             </msub>
             <mo>⁢</mo>
             <mi mathvariant="normal">⋯</mi>
             <mo>⁢</mo>
             <msub>
              <mi>σ</mi>
              <mi mathvariant="normal">ℓ</mi>
             </msub>
            </mrow>
           </mrow>
          </math>
         </inline-formula> of past symbols (before the current time) to update the state distribution as follows:
        </p>
       </list-item>
      </list>
      <p>
       <disp-formula id="equ18">
        <label>(17)</label>
        <math id="m18">
         <mrow>
          <mrow>
           <msup>
            <mi mathvariant="normal">℘</mi>
            <mrow>
             <mo stretchy="false">[</mo>
             <mi>k</mi>
             <mo stretchy="false">]</mo>
            </mrow>
           </msup>
           <mo>=</mo>
           <mrow>
            <mi>𝗇𝗈𝗋𝗆𝖺𝗅𝗂𝗓𝖾</mi>
            <mo>⁢</mo>
            <mrow>
             <mo>(</mo>
             <mrow>
              <msup>
               <mi mathvariant="normal">℘</mi>
               <mrow>
                <mo stretchy="false">[</mo>
                <mrow>
                 <mi>k</mi>
                 <mo>-</mo>
                 <mn>1</mn>
                </mrow>
                <mo stretchy="false">]</mo>
               </mrow>
              </msup>
              <mo>⁢</mo>
              <msub>
               <mi mathvariant="normal">Γ</mi>
               <msub>
                <mi>h</mi>
                <mi>k</mi>
               </msub>
              </msub>
             </mrow>
             <mo>)</mo>
            </mrow>
           </mrow>
          </mrow>
          <mo>,</mo>
          <mrow>
           <mi>k</mi>
           <mo>=</mo>
           <mrow>
            <mn>1</mn>
            <mo>,</mo>
            <mi mathvariant="normal">⋯</mi>
            <mo>,</mo>
            <mi mathvariant="normal">ℓ</mi>
           </mrow>
          </mrow>
         </mrow>
        </math>
       </disp-formula>where 
       <inline-formula>
        <math id="inf350">
         <msub>
          <mi>h</mi>
          <mi>k</mi>
         </msub>
        </math>
       </inline-formula> is the 
       <inline-formula>
        <math id="inf351">
         <msup>
          <mi>k</mi>
          <mrow>
           <mi>t</mi>
           <mo>⁢</mo>
           <mi>h</mi>
          </mrow>
         </msup>
        </math>
       </inline-formula> entry of the short history 
       <inline-formula>
        <math id="inf352">
         <mi>h</mi>
        </math>
       </inline-formula>, and 
       <inline-formula>
        <math id="inf353">
         <msup>
          <mi mathvariant="normal">℘</mi>
          <mrow>
           <mo stretchy="false">[</mo>
           <mi>k</mi>
           <mo stretchy="false">]</mo>
          </mrow>
         </msup>
        </math>
       </inline-formula> is the state distribution at step 
       <inline-formula>
        <math id="inf354">
         <mi>k</mi>
        </math>
       </inline-formula>. It follows from ergodicity that the updated distribution 
       <inline-formula>
        <math id="inf355">
         <msup>
          <mi mathvariant="normal">℘</mi>
          <mi mathvariant="normal">ℓ</mi>
         </msup>
        </math>
       </inline-formula> is an estimate of the current state distrbution.
      </p>
      <p>The predicted distribution over the symbol alphabet 
       <inline-formula>
        <math id="inf356">
         <mi mathvariant="normal">Δ</mi>
        </math>
       </inline-formula> steps in the future (if the time shift for the model is 
       <inline-formula>
        <math id="inf357">
         <mi mathvariant="normal">Δ</mi>
        </math>
       </inline-formula>), is then simply:
       <disp-formula id="equ19">
        <math id="m19">
         <mstyle displaystyle="true" scriptlevel="0">
          <mrow>
           <mstyle displaystyle="true" scriptlevel="0">
            <mi>P</mi>
            <mi>r</mi>
            <mo stretchy="false">(</mo>
            <msub>
             <mi>σ</mi>
             <mrow>
              <mrow>
               <mtext mathvariant="bold">predicted</mtext>
              </mrow>
             </mrow>
            </msub>
            <mo>=</mo>
            <mi>σ</mi>
            <mo stretchy="false">)</mo>
            <mo>=</mo>
            <munder>
             <mo>∑</mo>
             <mrow>
              <mi>q</mi>
              <mo>∈</mo>
              <mi>Q</mi>
             </mrow>
            </munder>
            <msubsup>
             <mi mathvariant="normal">℘</mi>
             <mrow>
              <mi>q</mi>
             </mrow>
             <mrow>
              <mi>ℓ</mi>
             </mrow>
            </msubsup>
            <mrow>
             <mover>
              <mi>π</mi>
              <mo>~</mo>
             </mover>
            </mrow>
            <mo stretchy="false">(</mo>
            <mi>q</mi>
            <mo>,</mo>
            <mi>σ</mi>
            <mo stretchy="false">)</mo>
           </mstyle>
          </mrow>
         </mstyle>
        </math>
       </disp-formula>where 
       <inline-formula>
        <math id="inf358">
         <msubsup>
          <mi mathvariant="normal">℘</mi>
          <mi>q</mi>
          <mi mathvariant="normal">ℓ</mi>
         </msubsup>
        </math>
       </inline-formula> is the current probability for state 
       <inline-formula>
        <math id="inf359">
         <mi>q</mi>
        </math>
       </inline-formula>, 
       <inline-formula>
        <math id="inf360">
         <mrow>
          <mrow>
           <mi>i</mi>
           <mo>.</mo>
           <mi>e</mi>
          </mrow>
          <mo>.</mo>
         </mrow>
        </math>
       </inline-formula>, the entry corresponding to state 
       <inline-formula>
        <math id="inf361">
         <mi>q</mi>
        </math>
       </inline-formula> in 
       <inline-formula>
        <math id="inf362">
         <msup>
          <mi mathvariant="normal">℘</mi>
          <mi mathvariant="normal">ℓ</mi>
         </msup>
        </math>
       </inline-formula>.
      </p>
     </sec>
     <sec id="s7-2-3">
      <title>Cross Models</title>
      <p>Unlike a self model, which attempts to predict future symbols in the same stream, a cross model attempts to predict symbols in a target stream after reading a short history in the source stream. Plate B(i) in 
       <xref ref-type="fig" rid="fig1">Figure 1</xref> illustrates a simple cross model with two states. Note that the model syntax is different from a PFSA; in particular, there are no probabilities on the arcs, though each state has a specified output distribution. Thus, if we see sequence 
       <inline-formula>
        <math id="inf363">
         <mn>101101</mn>
        </math>
       </inline-formula> in data stream 
       <inline-formula>
        <math id="inf364">
         <msub>
          <mi>s</mi>
          <mi>B</mi>
         </msub>
        </math>
       </inline-formula> (See 
       <xref ref-type="fig" rid="fig1">Figure 1</xref>, Plate B), then we are in state 
       <inline-formula>
        <math id="inf365">
         <msub>
          <mi>q</mi>
          <mn>2</mn>
         </msub>
        </math>
       </inline-formula> in the cross-model, and hence the next symbol in the data stream 
       <inline-formula>
        <math id="inf366">
         <msub>
          <mi>s</mi>
          <mi>A</mi>
         </msub>
        </math>
       </inline-formula> can be predicted to be 
       <inline-formula>
        <math id="inf367">
         <mn>0</mn>
        </math>
       </inline-formula> with a probability of 
       <inline-formula>
        <math id="inf368">
         <mn>0.7</mn>
        </math>
       </inline-formula> and 
       <inline-formula>
        <math id="inf369">
         <mn>1</mn>
        </math>
       </inline-formula> with a probability of 
       <inline-formula>
        <math id="inf370">
         <mn>0.3</mn>
        </math>
       </inline-formula>. We call such models crossed Probabilistic Finite State Automata (XPFSA) (
       <xref rid="bib22" ref-type="bibr">Chattopadhyay, 2014</xref>). A cross model state or an XPFSA has a slightly different interpretation from PFSA; while PFSA states are equivalence classes of histories that lead to identical futures in the same stream, the XPFSA are equivalence classes of histories in the source stream that lead to identical futures in the target stream (the future evolution in the target stream does not matter).
      </p>
      <p>XPFSA inference ˜ (
       <xref rid="bib22" ref-type="bibr">Chattopadhyay, 2014</xref>) is similar in principle to PFSA inference. Here, we have two input data streams, the source stream 
       <inline-formula>
        <math id="inf371">
         <msub>
          <mi>s</mi>
          <mi>A</mi>
         </msub>
        </math>
       </inline-formula> over the source alphabet 
       <inline-formula>
        <math id="inf372">
         <msub>
          <mi mathvariant="normal">Σ</mi>
          <mi>A</mi>
         </msub>
        </math>
       </inline-formula>, and the target stream 
       <inline-formula>
        <math id="inf373">
         <msub>
          <mi>s</mi>
          <mi>B</mi>
         </msub>
        </math>
       </inline-formula> over the source alphabet 
       <inline-formula>
        <math id="inf374">
         <msub>
          <mi mathvariant="normal">Σ</mi>
          <mi>B</mi>
         </msub>
        </math>
       </inline-formula>. The broad steps are as follows:
      </p>
      <list list-type="order">
       <list-item>
        <p>Let the set of all possible sequences up to a length 
         <inline-formula>
          <math id="inf375">
           <mi>L</mi>
          </math>
         </inline-formula> in source stream 
         <inline-formula>
          <math id="inf376">
           <msub>
            <mi>s</mi>
            <mi>A</mi>
           </msub>
          </math>
         </inline-formula> be denoted as 
         <inline-formula>
          <math id="inf377">
           <msubsup>
            <mi>S</mi>
            <mi>L</mi>
            <mi>A</mi>
           </msubsup>
          </math>
         </inline-formula>.
        </p>
       </list-item>
       <list-item>
        <p>Compute the probability of a future symbol (at a specified time shift) being 
         <inline-formula>
          <math id="inf378">
           <mrow>
            <mi>σ</mi>
            <mo>∈</mo>
            <msub>
             <mi mathvariant="normal">Σ</mi>
             <mi>B</mi>
            </msub>
           </mrow>
          </math>
         </inline-formula> in the target stream 
         <inline-formula>
          <math id="inf379">
           <msub>
            <mi>s</mi>
            <mi>B</mi>
           </msub>
          </math>
         </inline-formula> after a specific string 
         <inline-formula>
          <math id="inf380">
           <mi>ω</mi>
          </math>
         </inline-formula> from the set 
         <inline-formula>
          <math id="inf381">
           <msubsup>
            <mi>S</mi>
            <mi>L</mi>
            <mi>A</mi>
           </msubsup>
          </math>
         </inline-formula> is encountered in the source stream; call this distribution 
         <inline-formula>
          <math id="inf382">
           <msubsup>
            <mi>ϕ</mi>
            <mi>ω</mi>
            <mrow>
             <msub>
              <mi>s</mi>
              <mi>A</mi>
             </msub>
             <mo>,</mo>
             <msub>
              <mi>s</mi>
              <mi>B</mi>
             </msub>
            </mrow>
           </msubsup>
          </math>
         </inline-formula> for the string 
         <inline-formula>
          <math id="inf383">
           <mi>ω</mi>
          </math>
         </inline-formula>.
        </p>
       </list-item>
       <list-item>
        <p>Call the set of probability distributions obtained in this manner as 
         <inline-formula>
          <math id="inf384">
           <msup>
            <mi mathvariant="normal">Φ</mi>
            <mrow>
             <msub>
              <mi>s</mi>
              <mi>A</mi>
             </msub>
             <mo>,</mo>
             <msub>
              <mi>s</mi>
              <mi>B</mi>
             </msub>
            </mrow>
           </msup>
          </math>
         </inline-formula>.
        </p>
       </list-item>
       <list-item>
        <p>Find clusters in the set 
         <inline-formula>
          <math id="inf385">
           <msup>
            <mi mathvariant="normal">Φ</mi>
            <mrow>
             <msub>
              <mi>s</mi>
              <mi>A</mi>
             </msub>
             <mo>,</mo>
             <msub>
              <mi>s</mi>
              <mi>B</mi>
             </msub>
            </mrow>
           </msup>
          </math>
         </inline-formula>, such that the clusters are separated by some pre-specified distance 
         <inline-formula>
          <math id="inf386">
           <mrow>
            <mi>ϵ</mi>
            <mo>&gt;</mo>
            <mn>0</mn>
           </mrow>
          </math>
         </inline-formula>. These clusters now represent causal states of the cross-dependence between the stream (from 
         <inline-formula>
          <math id="inf387">
           <msub>
            <mi>s</mi>
            <mi>A</mi>
           </msub>
          </math>
         </inline-formula> to 
         <inline-formula>
          <math id="inf388">
           <msub>
            <mi>s</mi>
            <mi>B</mi>
           </msub>
          </math>
         </inline-formula>), because they are classes of histories (sequences) in the source stream that leads to identical, immediate futures in the target stream.
        </p>
       </list-item>
       <list-item>
        <p>Suppose string 
         <inline-formula>
          <math id="inf389">
           <mi>ω</mi>
          </math>
         </inline-formula> is in a cluster corresponding to state 
         <inline-formula>
          <math id="inf390">
           <msub>
            <mi>q</mi>
            <mi>i</mi>
           </msub>
          </math>
         </inline-formula>, and sequence 
         <inline-formula>
          <math id="inf391">
           <mrow>
            <mi>ω</mi>
            <mo>⁢</mo>
            <msub>
             <mi>σ</mi>
             <mn>0</mn>
            </msub>
           </mrow>
          </math>
         </inline-formula> is in a cluster corresponding to 
         <inline-formula>
          <math id="inf392">
           <msub>
            <mi>q</mi>
            <mi>j</mi>
           </msub>
          </math>
         </inline-formula>; it then follows that, in the inferred XPFSA, there is a transition labeled 
         <inline-formula>
          <math id="inf393">
           <msub>
            <mi>σ</mi>
            <mn>0</mn>
           </msub>
          </math>
         </inline-formula> from the corresponding state 
         <inline-formula>
          <math id="inf394">
           <msub>
            <mi>q</mi>
            <mi>i</mi>
           </msub>
          </math>
         </inline-formula> to state 
         <inline-formula>
          <math id="inf395">
           <msub>
            <mi>q</mi>
            <mi>j</mi>
           </msub>
          </math>
         </inline-formula>. Carrying out this procedure for each symbol of the source alphabet for each inferred cluster or state identifies the complete transition structure of the cross model. Note that the cross-model transitions are only labelled with symbols from the source alphabet.
        </p>
       </list-item>
       <list-item>
        <p>Once we have identified the transition structure, we choose an arbitrary initial state in the XPFSA and step through the model as dictated by the source data stream. Each time we reach a particular state in the cross-model, we note which symbol from target alphabet 
         <inline-formula>
          <math id="inf396">
           <msub>
            <mi mathvariant="normal">Σ</mi>
            <mi>B</mi>
           </msub>
          </math>
         </inline-formula> transpires in the target stream (at the specified time shift). Once we reach the end of the input source stream, we normalize the symbol count vectors corresponding to the cross-model states, and this determines the output distribution at each state. Note that each output distribution is a probability distribution over the target alphabet. This completes the XPFSA inference.
        </p>
       </list-item>
      </list>
      <p>An XPFSA may be thought of as a direct generalization of a PFSA, and any PFSA can be represented as an XPFSA. To illustrate this, note that predicting future symbols in the same stream can be thought of as predicting symbols is a second, but identical, copy of the first stream.</p>
      <p>If all histories in a source stream are equivalent in this sense, then we have a single state XPFSA, which implies that the source cannot provide any new information on what is going to happen in the target stream based on its own history. Hence, that source lacks any causal influence on the target. Thus, as before, the complexity of the inferred models is directly related to the statistical complexity (
       <xref rid="bib29" ref-type="bibr">Crutchfield, 1994</xref>) of the learnable, dynamical relationships underlying data streams themselves.
      </p>
      <p>XPFSAs are asymmetric in general; the model for how a source influences a target does not need to be identical when the roles played by the streams are reversed. However, two streams are statistically independent if and only if the XPFSAs in both directions are single state machines (
       <xref rid="bib22" ref-type="bibr">Chattopadhyay, 2014</xref>).
      </p>
      <p>This leads us to the notion of the causality coefficient, 
       <inline-formula>
        <math id="inf397">
         <msubsup>
          <mi>γ</mi>
          <mi>B</mi>
          <mi>A</mi>
         </msubsup>
        </math>
       </inline-formula>, from data stream 
       <inline-formula>
        <math id="inf398">
         <msub>
          <mi>s</mi>
          <mi>A</mi>
         </msub>
        </math>
       </inline-formula> to data stream 
       <inline-formula>
        <math id="inf399">
         <msub>
          <mi>s</mi>
          <mi>B</mi>
         </msub>
        </math>
       </inline-formula>. True to Granger’s notion of statistical causality, 
       <inline-formula>
        <math id="inf400">
         <msubsup>
          <mi>γ</mi>
          <mi>B</mi>
          <mi>A</mi>
         </msubsup>
        </math>
       </inline-formula> rigorously quantifies the amount of 
       <italic>additional</italic> information we can obtain about the immediate future in stream 
       <inline-formula>
        <math id="inf401">
         <msub>
          <mi>s</mi>
          <mi>B</mi>
         </msub>
        </math>
       </inline-formula> through observing stream 
       <inline-formula>
        <math id="inf402">
         <msub>
          <mi>s</mi>
          <mi>A</mi>
         </msub>
        </math>
       </inline-formula>.
      </p>
      <p>Explicitly, the coefficient is defined as the ratio of the expected change in the entropy of the next-symbol distribution in stream 
       <inline-formula>
        <math id="inf403">
         <msub>
          <mi>s</mi>
          <mi>B</mi>
         </msub>
        </math>
       </inline-formula> conditioned over observations in the stream 
       <inline-formula>
        <math id="inf404">
         <msub>
          <mi>s</mi>
          <mi>A</mi>
         </msub>
        </math>
       </inline-formula> to the entropy of the next-symbol distribution in stream 
       <inline-formula>
        <math id="inf405">
         <msub>
          <mi>s</mi>
          <mi>B</mi>
         </msub>
        </math>
       </inline-formula>, conditioned on the fact that no observations are made on stream 
       <inline-formula>
        <math id="inf406">
         <msub>
          <mi>s</mi>
          <mi>A</mi>
         </msub>
        </math>
       </inline-formula>. We show that causality coefficient 
       <inline-formula>
        <math id="inf407">
         <msubsup>
          <mi>γ</mi>
          <mi>B</mi>
          <mi>A</mi>
         </msubsup>
        </math>
       </inline-formula> takes values on the closed unit interval and that higher values indicate a stronger predictability of 
       <inline-formula>
        <math id="inf408">
         <msub>
          <mi>s</mi>
          <mi>B</mi>
         </msub>
        </math>
       </inline-formula> from 
       <inline-formula>
        <math id="inf409">
         <msub>
          <mi>s</mi>
          <mi>A</mi>
         </msub>
        </math>
       </inline-formula>, 
       <inline-formula>
        <math id="inf410">
         <mrow>
          <mrow>
           <mi>i</mi>
           <mo>.</mo>
           <mi>e</mi>
          </mrow>
          <mo>.</mo>
         </mrow>
        </math>
       </inline-formula>, therefore, a higher degree of causal influence. We have 
       <inline-formula>
        <math id="inf411">
         <mrow>
          <mi>γ</mi>
          <mo>=</mo>
          <mn>0</mn>
         </mrow>
        </math>
       </inline-formula> if and only if the inferred machine has a single state, and streams 
       <inline-formula>
        <math id="inf412">
         <mrow>
          <msub>
           <mi>s</mi>
           <mi>A</mi>
          </msub>
          <mo>,</mo>
          <msub>
           <mi>s</mi>
           <mi>B</mi>
          </msub>
         </mrow>
        </math>
       </inline-formula> are statistically independent if and only if 
       <inline-formula>
        <math id="inf413">
         <mrow>
          <msubsup>
           <mi>γ</mi>
           <mi>B</mi>
           <mi>A</mi>
          </msubsup>
          <mo>=</mo>
          <msubsup>
           <mi>γ</mi>
           <mi>A</mi>
           <mi>B</mi>
          </msubsup>
          <mo>=</mo>
          <mn>0</mn>
         </mrow>
        </math>
       </inline-formula>.
      </p>
      <p>Thus, the interpretation of the causality coefficient which is central to our development is as follows:</p>
      <p>
       <inline-formula>
        <math id="inf414">
         <mrow>
          <msubsup>
           <mi>γ</mi>
           <mi>B</mi>
           <mi>A</mi>
          </msubsup>
          <mo>=</mo>
          <mn>0.3</mn>
         </mrow>
        </math>
       </inline-formula>
       <italic>(say) from 
        <inline-formula>
         <math id="inf415">
          <msub>
           <mi>s</mi>
           <mi>A</mi>
          </msub>
         </math>
        </inline-formula> to 
        <inline-formula>
         <math id="inf416">
          <msub>
           <mi>s</mi>
           <mi>B</mi>
          </msub>
         </math>
        </inline-formula> means that we can acquire, on average, 
        <inline-formula>
         <math id="inf417">
          <mrow>
           <mpadded width="+5pt">
            <mn mathvariant="normal">0.3</mn>
           </mpadded>
           <mo mathvariant="italic">⁢</mo>
           <mi>b</mi>
           <mo mathvariant="italic">⁢</mo>
           <mi>i</mi>
           <mo mathvariant="italic">⁢</mo>
           <mi>t</mi>
           <mo mathvariant="italic">⁢</mo>
           <mi>s</mi>
          </mrow>
         </math>
        </inline-formula> of additional information about 
        <inline-formula>
         <math id="inf418">
          <msub>
           <mi>s</mi>
           <mi>B</mi>
          </msub>
         </math>
        </inline-formula> from each bit read from 
        <inline-formula>
         <math id="inf419">
          <msub>
           <mi>s</mi>
           <mi>A</mi>
          </msub>
         </math>
        </inline-formula>, over what is already available from the past history of 
        <inline-formula>
         <math id="inf420">
          <msub>
           <mi>s</mi>
           <mi>B</mi>
          </msub>
         </math>
        </inline-formula>.
       </italic>
      </p>
      <p>This is very different from computing correlations, and it assumes no model structure a priori for the hidden dynamics driving the data streams.</p>
      <p>Importantly, it turns out that inferring self models is simply a special case of cross model inference, in which the target stream is simply a time-shifted version of the first stream.</p>
     </sec>
     <sec id="s7-2-4">
      <title>Formal Definition of XPFSAs and Future Prediction</title>
      <p>Formally, an XPFSA is also a 
       <inline-formula>
        <math id="inf421">
         <mn>4</mn>
        </math>
       </inline-formula>-tuple 
       <inline-formula>
        <math id="inf422">
         <mrow>
          <msub>
           <mi>G</mi>
           <mrow>
            <mi>A</mi>
            <mo>→</mo>
            <mi>B</mi>
           </mrow>
          </msub>
          <mo>=</mo>
          <mrow>
           <mo stretchy="false">(</mo>
           <mi>Q</mi>
           <mo>,</mo>
           <msub>
            <mi mathvariant="normal">Σ</mi>
            <mi>A</mi>
           </msub>
           <mo>,</mo>
           <mi mathvariant="normal">Δ</mi>
           <mo>,</mo>
           <mover accent="true">
            <mi>π</mi>
            <mo>~</mo>
           </mover>
           <mo stretchy="false">)</mo>
          </mrow>
         </mrow>
        </math>
       </inline-formula>, where 
       <inline-formula>
        <math id="inf423">
         <mi>Q</mi>
        </math>
       </inline-formula> is a set of states, 
       <inline-formula>
        <math id="inf424">
         <msub>
          <mi mathvariant="normal">Σ</mi>
          <mi>A</mi>
         </msub>
        </math>
       </inline-formula> is the input alphabet. The transition function 
       <inline-formula>
        <math id="inf425">
         <mrow>
          <mi>δ</mi>
          <mo>:</mo>
          <mrow>
           <mrow>
            <mi>Q</mi>
            <mo>×</mo>
            <msub>
             <mi mathvariant="normal">Σ</mi>
             <mi>A</mi>
            </msub>
           </mrow>
           <mo>→</mo>
           <mi>Q</mi>
          </mrow>
         </mrow>
        </math>
       </inline-formula> is defined as before (in the case of the PFSA), but the symbol probability function is defined as 
       <inline-formula>
        <math id="inf426">
         <mrow>
          <mover accent="true">
           <mi>π</mi>
           <mo>~</mo>
          </mover>
          <mo>:</mo>
          <mrow>
           <mrow>
            <mi>Q</mi>
            <mo>×</mo>
            <msub>
             <mi mathvariant="normal">Σ</mi>
             <mi>B</mi>
            </msub>
           </mrow>
           <mo>→</mo>
           <mrow>
            <mo stretchy="false">[</mo>
            <mn>0</mn>
            <mo>,</mo>
            <mn>1</mn>
            <mo stretchy="false">]</mo>
           </mrow>
          </mrow>
         </mrow>
        </math>
       </inline-formula>, with
       <disp-formula id="equ20">
        <label>(18)</label>
        <math id="m20">
         <mrow>
          <mrow>
           <mrow>
            <mo>∀</mo>
            <mi>q</mi>
           </mrow>
           <mo>∈</mo>
           <mi>Q</mi>
          </mrow>
          <mo>,</mo>
          <mrow>
           <mrow>
            <munder>
             <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
             <mrow>
              <mi>σ</mi>
              <mo>∈</mo>
              <msub>
               <mi mathvariant="normal">Σ</mi>
               <mi>B</mi>
              </msub>
             </mrow>
            </munder>
            <mrow>
             <mover accent="true">
              <mi>π</mi>
              <mo>~</mo>
             </mover>
             <mo>⁢</mo>
             <mrow>
              <mo stretchy="false">(</mo>
              <mi>q</mi>
              <mo>,</mo>
              <mi>σ</mi>
              <mo stretchy="false">)</mo>
             </mrow>
            </mrow>
           </mrow>
           <mo>=</mo>
           <mn>1</mn>
          </mrow>
         </mrow>
        </math>
       </disp-formula>where 
       <inline-formula>
        <math id="inf427">
         <msub>
          <mi mathvariant="normal">Σ</mi>
          <mi>B</mi>
         </msub>
        </math>
       </inline-formula> is the target alphabet, which is distinct from 
       <inline-formula>
        <math id="inf428">
         <msub>
          <mi mathvariant="normal">Σ</mi>
          <mi>A</mi>
         </msub>
        </math>
       </inline-formula> in general. Note that the symbol distribution specified by 
       <inline-formula>
        <math id="inf429">
         <mover accent="true">
          <mi>π</mi>
          <mo>~</mo>
         </mover>
        </math>
       </inline-formula> is over the target alphabet 
       <inline-formula>
        <math id="inf430">
         <msub>
          <mi mathvariant="normal">Σ</mi>
          <mi>B</mi>
         </msub>
        </math>
       </inline-formula>.
      </p>
      <p>As before, there is a time shift 
       <inline-formula>
        <math id="inf431">
         <mi mathvariant="normal">Δ</mi>
        </math>
       </inline-formula> associated with inferred XPFSA, such that each symbol transition in the model maps to 
       <inline-formula>
        <math id="inf432">
         <mi mathvariant="normal">Δ</mi>
        </math>
       </inline-formula> steps in the target stream. If we know the current state of the XPFSA to be 
       <inline-formula>
        <math id="inf433">
         <msub>
          <mi>q</mi>
          <mn>0</mn>
         </msub>
        </math>
       </inline-formula>, and we observe symbol 
       <inline-formula>
        <math id="inf434">
         <mrow>
          <mi>σ</mi>
          <mo>∈</mo>
          <msub>
           <mi mathvariant="normal">Σ</mi>
           <mi>A</mi>
          </msub>
         </mrow>
        </math>
       </inline-formula> in the source stream, then the predicted symbol in the target stream (
       <inline-formula>
        <math id="inf435">
         <mi mathvariant="normal">Δ</mi>
        </math>
       </inline-formula> steps in the future) is 
       <inline-formula>
        <math id="inf436">
         <mrow>
          <msup>
           <mi>σ</mi>
           <mo>′</mo>
          </msup>
          <mo>∈</mo>
          <msub>
           <mi mathvariant="normal">Σ</mi>
           <mi>B</mi>
          </msub>
         </mrow>
        </math>
       </inline-formula>, with a probability of 
       <inline-formula>
        <math id="inf437">
         <mrow>
          <mover accent="true">
           <mi>π</mi>
           <mo>~</mo>
          </mover>
          <mo>⁢</mo>
          <mrow>
           <mo stretchy="false">(</mo>
           <mrow>
            <mi>δ</mi>
            <mo>⁢</mo>
            <mrow>
             <mo stretchy="false">(</mo>
             <msub>
              <mi>q</mi>
              <mn>0</mn>
             </msub>
             <mo>,</mo>
             <mi>σ</mi>
             <mo stretchy="false">)</mo>
            </mrow>
           </mrow>
           <mo>,</mo>
           <msup>
            <mi>σ</mi>
            <mo>′</mo>
           </msup>
           <mo stretchy="false">)</mo>
          </mrow>
         </mrow>
        </math>
       </inline-formula>.
      </p>
      <p>As before, determining the current state in the XPFSA is non-trivial. We estimate the current state distribution in a manner similar to that used for self models:</p>
      <list list-type="order">
       <list-item>
        <p>Note that the XPFSA graph does not have probabilities on it edges. However, the corresponding source stream’s self model does have symbol probabilities on its own edges, and it models the source stream. The problem is that the graph for the self model, and that of the cross model, might not be identical. We solve this problem using projective composition of probabilistic automata (
         <xref rid="bib21" ref-type="bibr">Chattopadhyay and Ray, 2008</xref>). This operation takes the self model for the source stream 
         <inline-formula>
          <math id="inf438">
           <msub>
            <mi>G</mi>
            <mi>A</mi>
           </msub>
          </math>
         </inline-formula>, and projects it on the inferred XPFSA graph 
         <inline-formula>
          <math id="inf439">
           <msub>
            <mi>G</mi>
            <mrow>
             <mi>A</mi>
             <mo>→</mo>
             <mi>B</mi>
            </mrow>
           </msub>
          </math>
         </inline-formula>, and the result is a PFSA 
         <inline-formula>
          <math id="inf440">
           <mrow>
            <mpadded width="+3pt">
             <msub>
              <mi>G</mi>
              <mi>A</mi>
             </msub>
            </mpadded>
            <mo>⁢</mo>
            <mover accent="true">
             <mo lspace="0pt">⊗</mo>
             <mo>→</mo>
            </mover>
            <mo>⁢</mo>
            <msub>
             <mi>G</mi>
             <mrow>
              <mi>A</mi>
              <mo>→</mo>
              <mi>B</mi>
             </mrow>
            </msub>
           </mrow>
          </math>
         </inline-formula> with the same structure as that of 
         <inline-formula>
          <math id="inf441">
           <msub>
            <mi>G</mi>
            <mrow>
             <mi>A</mi>
             <mo>→</mo>
             <mi>B</mi>
            </mrow>
           </msub>
          </math>
         </inline-formula>.
        </p>
       </list-item>
       <list-item>
        <p>Once we obtain 
         <inline-formula>
          <math id="inf442">
           <mrow>
            <mpadded width="+3pt">
             <msub>
              <mi>G</mi>
              <mi>A</mi>
             </msub>
            </mpadded>
            <mo>⁢</mo>
            <mover accent="true">
             <mo lspace="0pt">⊗</mo>
             <mo>→</mo>
            </mover>
            <mo>⁢</mo>
            <msub>
             <mi>G</mi>
             <mrow>
              <mi>A</mi>
              <mo>→</mo>
              <mi>B</mi>
             </mrow>
            </msub>
           </mrow>
          </math>
         </inline-formula>, we can estimate its current state as described in the case for self models (using observed symbols in the source stream).
        </p>
       </list-item>
       <list-item>
        <p>Let the current state distribution be 
         <inline-formula>
          <math id="inf443">
           <msup>
            <mover accent="true">
             <mi mathvariant="normal">℘</mi>
             <mo>¯</mo>
            </mover>
            <mi mathvariant="normal">ℓ</mi>
           </msup>
          </math>
         </inline-formula>. Then, the predicted future symbol (at time shift 
         <inline-formula>
          <math id="inf444">
           <mi mathvariant="normal">Δ</mi>
          </math>
         </inline-formula>) in the target stream is 
         <inline-formula>
          <math id="inf445">
           <mrow>
            <msup>
             <mi>σ</mi>
             <mo>′</mo>
            </msup>
            <mo>∈</mo>
            <msub>
             <mi mathvariant="normal">Σ</mi>
             <mi>B</mi>
            </msub>
           </mrow>
          </math>
         </inline-formula> with a probability of:
        </p>
       </list-item>
      </list>
      <p>
       <disp-formula id="equ21">
        <math id="m21">
         <mrow>
          <mi>P</mi>
          <mi>r</mi>
          <mrow>
           <mo stretchy="false">(</mo>
           <msub>
            <mi>σ</mi>
            <mtext>𝐩𝐫𝐞𝐝𝐢𝐜𝐭𝐞𝐝</mtext>
           </msub>
           <mo>=</mo>
           <msup>
            <mi>σ</mi>
            <mo>′</mo>
           </msup>
           <mo stretchy="false">)</mo>
          </mrow>
          <mo>=</mo>
          <munder>
           <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
           <mrow>
            <mi>q</mi>
            <mo>∈</mo>
            <mi>Q</mi>
           </mrow>
          </munder>
          <msubsup>
           <mover accent="true">
            <mi mathvariant="normal">℘</mi>
            <mo>¯</mo>
           </mover>
           <mi>q</mi>
           <mi mathvariant="normal">ℓ</mi>
          </msubsup>
          <mover accent="true">
           <mi>π</mi>
           <mo>~</mo>
          </mover>
          <mrow>
           <mo stretchy="false">(</mo>
           <mi>q</mi>
           <mo>,</mo>
           <msup>
            <mi>σ</mi>
            <mo>′</mo>
           </msup>
           <mo stretchy="false">)</mo>
          </mrow>
         </mrow>
        </math>
       </disp-formula>where 
       <inline-formula>
        <math id="inf446">
         <mrow>
          <mpadded width="+3pt">
           <msub>
            <mi>G</mi>
            <mi>A</mi>
           </msub>
          </mpadded>
          <mo>⁢</mo>
          <mover accent="true">
           <mo lspace="0pt">⊗</mo>
           <mo>→</mo>
          </mover>
          <mo>⁢</mo>
          <msub>
           <mi>G</mi>
           <mrow>
            <mi>A</mi>
            <mo>→</mo>
            <mi>B</mi>
           </mrow>
          </msub>
         </mrow>
        </math>
       </inline-formula> (note we are using the 
       <inline-formula>
        <math id="inf447">
         <mover accent="true">
          <mi>π</mi>
          <mo>~</mo>
         </mover>
        </math>
       </inline-formula> from the XPFSA, and not from the projected PFSA).
      </p>
     </sec>
     <sec id="s7-2-5">
      <title>Computation of the Coefficient of Causality</title>
      <p>Let 
       <inline-formula>
        <math id="inf448">
         <mrow>
          <msub>
           <mi class="ltx_font_mathcaligraphic">ℋ</mi>
           <mi>A</mi>
          </msub>
          <mo>,</mo>
          <msub>
           <mi class="ltx_font_mathcaligraphic">ℋ</mi>
           <mi>B</mi>
          </msub>
         </mrow>
        </math>
       </inline-formula> be stationary ergodic processes over finite alphabets 
       <inline-formula>
        <math id="inf449">
         <mrow>
          <msub>
           <mi mathvariant="normal">Σ</mi>
           <mi>A</mi>
          </msub>
          <mo>,</mo>
          <msub>
           <mi mathvariant="normal">Σ</mi>
           <mi>B</mi>
          </msub>
         </mrow>
        </math>
       </inline-formula> respectively. Then, the causal dependence coefficient of 
       <inline-formula>
        <math id="inf450">
         <msub>
          <mi class="ltx_font_mathcaligraphic">ℋ</mi>
          <mi>B</mi>
         </msub>
        </math>
       </inline-formula> on 
       <inline-formula>
        <math id="inf451">
         <msub>
          <mi class="ltx_font_mathcaligraphic">ℋ</mi>
          <mi>A</mi>
         </msub>
        </math>
       </inline-formula>, denoted as 
       <inline-formula>
        <math id="inf452">
         <msubsup>
          <mi>γ</mi>
          <mi>B</mi>
          <mi>A</mi>
         </msubsup>
        </math>
       </inline-formula>, is formally defined as the ratio of the expected change in the entropy of the next symbol distribution in 
       <inline-formula>
        <math id="inf453">
         <msub>
          <mi class="ltx_font_mathcaligraphic">ℋ</mi>
          <mi>B</mi>
         </msub>
        </math>
       </inline-formula>. This is due to observations in 
       <inline-formula>
        <math id="inf454">
         <msub>
          <mi class="ltx_font_mathcaligraphic">ℋ</mi>
          <mi>A</mi>
         </msub>
        </math>
       </inline-formula>, which show the entropy of the next symbol distribution in 
       <inline-formula>
        <math id="inf455">
         <msub>
          <mi class="ltx_font_mathcaligraphic">ℋ</mi>
          <mi>B</mi>
         </msub>
        </math>
       </inline-formula>. In the absence of data in 
       <inline-formula>
        <math id="inf456">
         <msub>
          <mi class="ltx_font_mathcaligraphic">ℋ</mi>
          <mi>A</mi>
         </msub>
        </math>
       </inline-formula>, 
       <inline-formula>
        <math id="inf457">
         <mrow>
          <mrow>
           <mi>i</mi>
           <mo>.</mo>
           <mi>e</mi>
          </mrow>
          <mo>.</mo>
         </mrow>
        </math>
       </inline-formula>, we have (
       <xref rid="bib22" ref-type="bibr">Chattopadhyay, 2014</xref>):
       <disp-formula id="equ22">
        <label>(19)</label>
        <math id="m22">
         <mrow>
          <msubsup>
           <mi>γ</mi>
           <mi>B</mi>
           <mi>A</mi>
          </msubsup>
          <mo>=</mo>
          <mrow>
           <mn>1</mn>
           <mo>-</mo>
           <mfrac>
            <mrow>
             <mo>𝐄</mo>
             <mrow>
              <mo>(</mo>
              <mrow>
               <mi mathvariant="bold-italic">𝒉</mi>
               <mo>⁢</mo>
               <mrow>
                <mo>(</mo>
                <msubsup>
                 <mi>ϕ</mi>
                 <mi>x</mi>
                 <mrow>
                  <msub>
                   <mi class="ltx_font_mathcaligraphic">ℋ</mi>
                   <mi>A</mi>
                  </msub>
                  <mo>,</mo>
                  <msub>
                   <mi class="ltx_font_mathcaligraphic">ℋ</mi>
                   <mi>B</mi>
                  </msub>
                 </mrow>
                </msubsup>
                <mo>)</mo>
               </mrow>
              </mrow>
              <mo>)</mo>
             </mrow>
            </mrow>
            <mrow>
             <mi mathvariant="bold-italic">𝒉</mi>
             <mo>⁢</mo>
             <mrow>
              <mo>(</mo>
              <msubsup>
               <mi>ϕ</mi>
               <mi>λ</mi>
               <mrow>
                <msub>
                 <mi class="ltx_font_mathcaligraphic">ℋ</mi>
                 <mi>A</mi>
                </msub>
                <mo>,</mo>
                <msub>
                 <mi class="ltx_font_mathcaligraphic">ℋ</mi>
                 <mi>B</mi>
                </msub>
               </mrow>
              </msubsup>
              <mo>)</mo>
             </mrow>
            </mrow>
           </mfrac>
          </mrow>
         </mrow>
        </math>
       </disp-formula>where the entropy 
       <inline-formula>
        <math id="inf458">
         <mrow>
          <mi mathvariant="bold-italic">𝒉</mi>
          <mo>⁢</mo>
          <mrow>
           <mo>(</mo>
           <mi>u</mi>
           <mo>)</mo>
          </mrow>
         </mrow>
        </math>
       </inline-formula> of discrete probability distribution 
       <inline-formula>
        <math id="inf459">
         <mi>u</mi>
        </math>
       </inline-formula> is given by 
       <inline-formula>
        <math id="inf460">
         <mrow>
          <msub>
           <mo largeop="true" symmetric="true">∑</mo>
           <mi>i</mi>
          </msub>
          <mrow>
           <msub>
            <mi>u</mi>
            <mi>i</mi>
           </msub>
           <mo>⁢</mo>
           <mrow>
            <msub>
             <mi>log</mi>
             <mn>2</mn>
            </msub>
            <mo>⁡</mo>
            <msub>
             <mi>u</mi>
             <mi>i</mi>
            </msub>
           </mrow>
          </mrow>
         </mrow>
        </math>
       </inline-formula>, 
       <inline-formula>
        <math id="inf461">
         <mi>λ</mi>
        </math>
       </inline-formula> is the empty string, and 
       <inline-formula>
        <math id="inf462">
         <mrow>
          <mi mathvariant="bold">𝐄</mi>
          <mo>⁢</mo>
          <mrow>
           <mo stretchy="false">(</mo>
           <mo>⋅</mo>
           <mo stretchy="false">)</mo>
          </mrow>
         </mrow>
        </math>
       </inline-formula> is the expectation operator over all possible sequences in the source stream. Once we infer the cross model, computing 
       <inline-formula>
        <math id="inf463">
         <msubsup>
          <mi>γ</mi>
          <mi>B</mi>
          <mi>A</mi>
         </msubsup>
        </math>
       </inline-formula> is straightforward.
      </p>
     </sec>
     <sec id="s7-2-6">
      <title>Choice of Quantization Schemes</title>
      <p>The weekly time series of county-specific records for the number of reported influenza cases is quantized to a binary stream. If 
       <inline-formula>
        <math id="inf464">
         <msub>
          <mi>y</mi>
          <mi>k</mi>
         </msub>
        </math>
       </inline-formula> is the number of reported cases for a given fixed county at the week index 
       <inline-formula>
        <math id="inf465">
         <mi>k</mi>
        </math>
       </inline-formula>, then the quantized binary stream 
       <inline-formula>
        <math id="inf466">
         <msub>
          <mover accent="true">
           <mi>y</mi>
           <mo>¯</mo>
          </mover>
          <mi>k</mi>
         </msub>
        </math>
       </inline-formula> is obtained as follows:
       <disp-formula id="equ23">
        <label>(20)</label>
        <math id="m23">
         <mrow>
          <msub>
           <mover accent="true">
            <mi>y</mi>
            <mo>¯</mo>
           </mover>
           <mi>k</mi>
          </msub>
          <mo>=</mo>
          <mrow>
           <mo>{</mo>
           <mtable displaystyle="true">
            <mtr>
             <mtd columnalign="left">
              <mn>1</mn>
             </mtd>
             <mtd columnalign="left">
              <mrow>
               <mrow>
                <mtext>if </mtext>
                <mo>⁢</mo>
                <msub>
                 <mi>y</mi>
                 <mi>k</mi>
                </msub>
               </mrow>
               <mo>&gt;</mo>
               <msub>
                <mi>y</mi>
                <mrow>
                 <mi>k</mi>
                 <mo>-</mo>
                 <mn>1</mn>
                </mrow>
               </msub>
              </mrow>
             </mtd>
            </mtr>
            <mtr>
             <mtd columnalign="left">
              <mn>0</mn>
             </mtd>
             <mtd columnalign="left">
              <mtext>otherwise</mtext>
             </mtd>
            </mtr>
           </mtable>
           <mi/>
          </mrow>
         </mrow>
        </math>
       </disp-formula>
      </p>
     </sec>
    </sec>
   </boxed-text>
  </sec>
 </app>
</app-group>
